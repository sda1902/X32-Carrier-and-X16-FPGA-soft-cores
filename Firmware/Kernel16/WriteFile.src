;
; 1 check the catalog object if no catalog then create him
; 2 check filename
; 3 check available size
; 4 create and write header
; 5 write raw data
;
	align 2
WriteFile:
pushd	r0
pushd	r1
pushd	r2
pushd	r3
pushd	r4
pushd	r5
pushd	r6
pushd	r7
pushd	r8
pushd	r9
pushd	r10
pushd	r11
pushd	r12
pushd	r13
pushd	r14
pushd	r15
pusha	ar0
pusha	ar1
pusha	ar2
pusha	ar3
pusha	ar4
pusha	ar5
pusha	ar6
pusha	ar7
pusha	ar8
pusha	ar9
; read object selector
		li			r0,Offset ReadHexParam shl 1
		li			r0,Offset ReadHexParam shr 7
		call		r0
		lar			ar5,r0							; MAR2 - pointer to the object
		amode		r5,4							; autoincrement for string comparison
		ldb			r0,mar3:r5
		or			r0,r0:r0
		jc			r0:nzf,Displacement WF00
		jnear		Displacement WFEnd
WF00:
		amode		r0,2
; set master CPU number
		li			r0,(Offset CmdStates shl 1)+3
		li			r0,Offset CmdStates shr 7
		li			r13,0
		ldb			r13,mar6:r0
		size		r13,qword
		lsli		r13:12
		lsli		r13:12
; check Flash ready
		li			r0,FlashCtrlSelector
		or			r0,r0:r13
		lar			ar1,r0
		li			r6,5
		li			r0,2
		st			mar0:r0,r6
		li			r7,FlashDataSelector
		or			r7,r7:r13
		lar			ar1,r7
		li			r0,0
WF0:
		ldb			r6,mar0:r0
		lsri		r6:1
		jc			r6:dbf,Displacement WF0
		li			r0,FlashCtrlSelector
		or			r0,r0:r13
		lar			ar1,r0
		li			r0,2
		li			r6,0bh								; read instruction
		st			mar0:r0,r6
		lar			ar1,r7							; MAR0 - pointer to the catalog object
		lar			ar3,r7							; MAR1 - copy of pointer for compare filename
		li			r1,0
		li			r1,10h							; R1=4096 for increment address
		amode		r1,1
		li			r2,0
		size		r2,word							; count of free blocks
		lar			ar0,r1							; start from 1000h
		li			r3,1							; constant 1
		li			r0,4095							; number of entries LOOP counter
		li			r0,4095 shr 8
; scanning file table
WF2:
		sar			r4,ar0
		ldd			r5,mar0:r1
		add			r6,r5:r3
		jc			r6:nzf,Displacement WF3
; if empty block found
		add			r2,r2:r3
WF210:
		loop		r0,Displacement WF2
		jnear		Displacement WFNoFileExists
; if non-empty entry
WF3:
		lsli		r5:8
		lsli		r5:8
		jc			r5:nzf,Displacement WF210
; if start entry found checkin filename
		li			r6,32
		add			r4,r6:r4						; offset to the filename
		lar			ar2,r4
		sar			r4,ar6							; store pointer to the new filename
WF4:
		ldb			r5,mar1:r5
		ldb			r6,mar3:r5
		xor			r7,r5:r6
		jc			r7:nzf,Displacement WF5
		or			r5,r5:r6
		jc			r5:zf,Displacement WFFileExists
		jnear		Displacement WF4
; if strings not equal
WF5:
		lar			ar6,r4							; restore pointer to the new filename
		loop		r0,Displacement WF2
		jnear		Displacement WFNoFileExists
; if File exists
WFFileExists:
		li			r0,Offset FileExistsString shl 1
		li			r0,Offset FileExistsString shr 7
WF6:
		sar			r1,ar13
		li			r2,Offset OutString shl 1
		li			r2,Offset OutString shr 7
		call		r2
WFEnd:
popa	ar9
popa	ar8
popa	ar7
popa	ar6
popa	ar5
popa	ar4
popa	ar3
popa	ar2
popa	ar1
popa	ar0
popd	r15
popd	r14
popd	r13
popd	r12
popd	r11
popd	r10
popd	r9
popd	r8
popd	r7
popd	r6
popd	r5
popd	r4
popd	r3
popd	r2
popd	r1
popd	r0
ret
; if no file exists then checkin available size and object size. R2 - count of free blocks
WFNoFileExists:
		sar			r0,ar5
		li			r4,Offset GetObjectSize shl 1
		li			r4,Offset GetObjectSize shr 7
		call		r4									; calculate object size in 32-byte paragraphs
		copy		r15,r0								; R15 copy of object length
		size		r15,dword
		lsli		r15:3
		li			r4,8
		add			r0,r0:r4
		lsri		r0:7
		add			r0,r0:r3							; length in 4096 blocks
		size		r0,word
		neg			r0
		add			r4,r2:r0
		jc      	r4:cf,Displacement WFSizeOK
		li			r0,Offset NoFreeSizeString shl 1
		li			r0,Offset NoFreeSizeString shr 7
		jnear		Displacement WF6
; if free Size is good for file then seek first free sector
; registers assignment
; R15 - length of the object (rest of) in dwords
; R1 - constant 4096 for seek free sectors
;		create file header and first file block
; R3 - constant 1
WFSizeOK:
		li			r0,0
		lar			ar4,r0								; MAR2 pointer to object data
		lar 		ar0,r1								; MAR0 pointer to object catalog
		amode		r0,4
		lar			ar2,r0								; reset pointer to the write buffer
		li			r0,FlashWBSelector
		or			r0,r0:r13
		lar			ar3,r0								; MAR1 pointer to flash write buffer
		li			r14,Offset SetWriteEnable shl 1
		li			r14,Offset SetWriteEnable shr 7
		call		r14									; turn ON write enable bit
		li			r0,2
		st			mar1:r0,r0							; page program instruction
; search free block
WF7:
		sar			r4,ar0								; store pointer
		ldd			r0,mar0:r1
		add			r0,r0:r3
		jc			r0:nzf,Displacement WF7
; R4 - address of the first block find free block check object length
		li			r5,0
		li			r0,-960								
		li			r0,-960 shr 8						; maximum length of the object, which can be saved into first block
		add			r0,r15:r0
		jc			r0:ncf,Displacement WF9				; go, if file can be saved into one block
; if need to find next free block
WF8:
		sar			r5,ar0
		ldd			r0,mar0:r1
		add			r0,r0:r3
		jc			r0:nzf,Displacement WF8
; R4 - pointer to the first block, R5 - pointer to the next block
WF9:
		copy		r0,r4								; set page address
		size		r0,dword
		lsli		r0:8								; convert to 24 bit address
		csli		r0:8
		size		r0,byte
		st			mar1:r0,r0							; high address byte
		size		r0,dword
		csli		r0:8
		size		r0,byte
		st			mar1:r0,r0							; medium byte
		li			r0,0
		st			mar1:r0,r0							; low byte
; 
		size	r0,word
		st		mar1:r0,r0							; lower link index for first block
		copy	r0,r5
		lsri	r0:12								; upper link idex
		size	r0,word
		st		mar1:r0,r0
; position for CRC code
		li		r0,0FFh
		size	r0,dword
		st		mar1:r0,r0
; set the file length
		copy	r0,r15
		size	r0,dword
		lsli	r0:2
		st		mar1:r0,r0
		li		r0,0
		st		mar1:r0,r0
; atribute byte
		li		r0,0FFh
		st		mar1:r0,r0
; set timestamp
		size	r0,word
		st		mar1:r0,r0
		size	r0,dword
		st		mar1:r0,r0
		st		mar1:r0,r0
		size	r0,word
		st		mar1:r0,r0
; reserved 6 bytes
		st		mar1:r0,r0
		st		mar1:r0,r0
		st		mar1:r0,r0
; copy filename
WF10:
		ldb		r0,mar3:r0
		st		mar1:r0,r0
		or		r0,r0:r0
		jc		r0:nzf,Displacement WF10
; fill rest of page by code 0FFh
		sar		r6,ar2
		li		r0,260
		neg		r6
		li		r0,260 shr 8
		add		r6,r0:r6
		li		r0,0FFh
WF11:
		st		mar1:r0,r0
		loop	r6,Displacement WF11
		
; calculate CRC for first block
		li		r6,IOSelector
		lar		ar7,r6							; MAR3 - IO registers
		li		r6,18h
		lar		ar6,r6
		size	r0,dword
		st		mar3:r0,r0						; initial state of the CRC and promote pointer to data entrance
		li		r0,12							; offset first byte
		lar		ar2,r0
		amode	r6,0
		li		r0,256-8
		li		r0,(256-8) shr 8				; count of bytes
WF12:
		ldb		r6,mar1:r0
		st		mar3:r6,r6
		loop	r0,Displacement WF12
; calculate CRC of data
		li		r7,960
		li		r7,960 shr 8
		size	r7,dword
		copy	r6,r7
		neg		r6
		add		r0,r15:r6
		jc		r0:cf,Displacement WF13
; if length less than 960 dwords
		copy	r7,r15
WF13:
		sar		r8,ar4							; store source offset
		copy	r6,r7							; copy of processed dwords
		lsri	r6:1							; count of qwords
WF14:
		ldq		r0,mar2:r0
		size	r0,byte
		st		mar3:r6,r0						; 0
		size	r0,qword
		lsri	r0:8
		size	r0,byte
		st		mar3:r6,r0						; 1
		size	r0,qword
		lsri	r0:8
		size	r0,byte
		st		mar3:r6,r0						; 2
		size	r0,qword
		lsri	r0:8
		size	r0,byte
		st		mar3:r6,r0						; 3
		size	r0,qword
		lsri	r0:8
		size	r0,byte
		st		mar3:r6,r0						; 4
		size	r0,qword
		lsri	r0:8
		size	r0,byte
		st		mar3:r6,r0						; 5
		size	r0,qword
		lsri	r0:8
		size	r0,byte
		st		mar3:r6,r0						; 6
		size	r0,qword
		lsri	r0:8
		size	r0,byte
		st		mar3:r6,r0						; 7
		loop	r6,Displacement WF14
		lar		ar4,r8							; restore source offset
		li		r0,18h
		lar		ar6,r0
		ldd		r6,mar3:r6						; read calculated CRC
		li		r0,8
		lar		ar2,r0
		st		mar1:r6,r6						; store CRC
		copy	r9,r4							; copy of block
; transfer data to the flash
		li		r6,260
		li		r6,260 shr 8
		li			r0,FlashCtrlSelector
		or			r0,r0:r13
		lar		ar9,r0							; MAR4 - pointer to the flash control register 1000000h
		li		r0,0
		lar		ar8,r0
		st		mar4:r6,r6						; write file header
		li		r0,0
		li		r0,1
		add		r4,r4:r0						; address for write data
		copy	r8,r7
		li		r0,Offset WriteRestOfBlock shl 1
		li		r0,Offset WriteRestOfBlock shr 7
		call	r0
		copy	r7,r8
		neg		r7
		add		r15,r15:r7
; cycle for write all next data
WFBlockCycle:
		jc		r15:nzf,Displacement WF16
; if all data was writen
		jnear	Displacement WFWriteOK
; if data present
WF16:
		copy	r4,r5
		add		r5,r5:r1
		lar		ar0,r5
		li		r5,0
		copy	r7,r15
		size	r5,dword
		li		r0,-1022								; dwords, which can be saved into regular block
		li		r0,-1022 shr 8
		add		r0,r15:r0
		jc		r0:cf,Displacement WF170
		jnear	Displacement WF18					; go, if file can be saved into one block
; if need to find next free block check ready
WF170:
		li		r0,2
		lar		ar8,r0
		li		r6,05h
		st		mar4:r6,r6
		li			r0,FlashDataSelector
		or			r0,r0:r13
		lar		ar7,r0
		li		r0,0
		lar		ar6,r0
WF171:
		ldb		r0,mar3:r6
		lsri	r0:1
		jc		r0:dbf,displacement WF171
		li		r6,0bh								; read instruction
		st		mar4:r6,r6

WF17:
		sar		r5,ar0
		ldd		r0,mar0:r1
		add		r0,r0:r3
		jc		r0:nzf,Displacement WF17
		li		r7,1022
		li		r7,1022 shr 8
; R4 - pointer to the current block, R5 - pointer to the next block create header of the first page R9 - pointer to the previous block
WF18:
; wait for ready
		li		r0,2
		lar		ar8,r0
		li		r6,05h
		st		mar4:r6,r6
		li			r0,FlashDataSelector
		or			r0,r0:r13
		lar		ar7,r0
		li		r0,0
		lar		ar6,r0
WF181:
		ldb		r0,mar3:r6
		lsri	r0:1
		jc		r0:dbf,displacement WF181
; if flash ready
		li		r0,Offset SetWriteEnable shl 1
		li		r0,Offset SetWriteEnable shr 7
		call	r0
		li		r0,0
		lar		ar2,r0
		li		r0,2
		st		mar1:r0,r0
		copy	r0,r4								; set page address
		lar		ar0,r4
		size	r0,dword
		lsli	r0:8								; convert to 24 bit address
		csli	r0:8
		size	r0,byte
		st		mar1:r0,r0							; high address byte
		size	r0,dword
		csli	r0:8
		size	r0,byte
		st		mar1:r0,r0							; medium byte
		li		r0,0
		st		mar1:r0,r0							; low byte
; 
		copy	r0,r9
		lsri	r0:12								; 
		size	r0,word
		st		mar1:r0,r0							; lower link index for first block
		copy	r0,r5
		lsri	r0:12								; upper link idex
		size	r0,word
		st		mar1:r0,r0
; calculate CRC for block
		li		r0,IOSelector
		lar		ar7,r0
		li		r0,18h
		lar		ar6,r0
		li		r0,0FFh
		size	r0,dword
		st		mar3:r0,r0							; initial CRC value and increment pointer to the data register
		sar		r8,ar4								; start address of data
		copy	r6,r7
WF20:
		ldd		r0,mar2:r0
		size	r0,byte
		st		mar3:r6,r0							;0
		size	r0,dword
		lsri	r0:8
		size	r0,byte
		st		mar3:r6,r0							;1
		size	r0,dword
		lsri	r0:8
		size	r0,byte
		st		mar3:r6,r0							;2
		size	r0,dword
		lsri	r0:8
		size	r0,byte
		st		mar3:r6,r0							;3
		loop	r6,Displacement WF20
		lar		ar4,r8								; restore start address
		li		r0,18h
		lar		ar6,r0
		ldd		r6,mar3:r6						; read calculated CRC
		st		mar1:r0,r6						; set CRC into header
; copy data to the buffer
		li		r6,62
		size	r6,dword
		copy	r0,r6
		neg		r0
		add		r0,r7:r0
		jc		r0:cf,Displacement WF21
		copy	r6,r7
WF21:
		copy	r8,r6
WF22:
		ldd		r0,mar2:r0
		st		mar1:r0,r0
		loop	r6,Displacement WF22
; send write command
		li		r6,260
		li		r6,260 shr 8
		li		r0,0
		lar		ar8,r0
		st		mar4:r6,r6						; write file header
; decrement R7
		neg		r8
		add		r7,r7:r8
		add		r15,r15:8
		copy	r9,r4
		li		r0,0
		li		r0,1
		add		r4,r4:r0						; address for write data
		copy	r8,r7
		li		r0,Offset WriteRestOfBlock shl 1
		li		r0,Offset WriteRestOfBlock shr 7
		call	r0
		neg		r8
		add		r15,r15:r8
		jnear	Displacement WFBlockCycle
		
; end of write file
WFWriteOK:
		amode	r0,2
		li			r0,FlashCtrlSelector
		or			r0,r0:r13
		lar			ar1,r0
		li			r6,5
		li			r0,2
		st			mar0:r0,r6
		li			r7,FlashDataSelector
		or			r7,r7:r13
		lar			ar1,r7
		li			r0,0
; check Flash ready
WFWOK:
		ldb			r6,mar0:r0
		lsri		r6:1
		jc			r6:dbf,Displacement WFWOK
		li			r0,FlashCtrlSelector
		or			r0,r0:r13
		lar			ar1,r0
		li			r0,2
		li			r6,0bh								; read instruction
		st			mar0:r0,r6

		li			r0,IOSelector
		jc			r13:zf,Displacement WFWOK0
		xor			r0,r0:r0
		li			r0,EchoStreamSelector
		or			r0,r0:r13
WFWOK0:
		lar		ar1,r0
		amode	r1,2
		li		r1,8
		li		r0,57h
		st		mar0:r1,r0
		li		r0,46h
		st		mar0:r1,r0
		li		r0,0dh
		st		mar0:r1,r0
		li		r0,0ah
		st		mar0:r1,r0
		li		r2,Offset WFEnd shl 1
		li		r2,Offset WFEnd shr 7
		jump	r2

	align 2
FileExistsString:
		byte 'File already exists',0
	align 2
NoFreeSizeString:
		byte 'Not enougth free size',0

;
;--------------------------------------------------------------------------------------------------
; 			Set write enable 
;
	align 2
SetWriteEnable:
pushd	r0
pusha	ar0
pusha	ar1
		li			r0,0
		lar			ar0,r0
		li			r0,FlashWBSelector
		or			r0,r0:r13
		lar			ar1,r0
		li			r0,06h
		amode		r0,0
		st			mar0:r0,r0
		li			r0,FlashCtrlSelector
		or			r0,r0:r13
		lar			ar1,r0
		li			r0,1
		size		r0,word
		st			mar0:r0,r0
popa	ar1
popa	ar0
popd	r0
ret
;
;--------------------------------------------------------------------------------------------------
;			write rest of block
; R7 - data count in dwords
; MAR2 - pointer to the first byte in object
; R4 - offset for flash
; MAR4 - pointer to flash ctrl register
; MAR1 - pointer to the flash write buffer
; MAR3 - pointer to flash data
;
WriteRestOfBlock:
		or		r7,r7:r7
		jc		r7:nzf,displacement WROB2
		ret
WROB2:
		li		r0,2
		lar		ar8,r0
		li		r6,05h
		st		mar4:r6,r6
		li			r0,FlashDataSelector
		or			r0,r0:r13
		lar			ar7,r0
		li		r0,0
		lar		ar6,r0
WROB3:
		ldb		r0,mar3:r6
		lsri	r0:1
		jc		r0:dbf,displacement WROB3
		li		r0,Offset SetWriteEnable shl 1
		li		r0,Offset SetWriteEnable shr 7
		call	r0
		li		r0,0
		lar		ar2,r0
		amode	r0,4
		li		r0,2
		st		mar1:r0,r0					; instruction
; set address
		copy	r0,r4
		li		r6,0
		li		r6,1
		add		r4,r4:r6					; promote pointer
		size	r0,dword
		lsli	r0:8
		csli	r0:8
		size	r0,byte
		st		mar1:r0,r0					; high address byte
		size	r0,dword
		csli	r0:8
		size	r0,byte
		st		mar1:r0,r0					; med byte
		size	r0,dword
		csli	r0:8
		size	r0,byte
		st		mar1:r0,r0					; low byte
; set length of copied data
		li		r6,64
		size	r6,dword
		li		r0,-64
		add		r0,r7:r0
		jc		r0:cf,Displacement WROB0
		copy	r6,r7
WROB0:
		copy	r0,r6
		neg		r0
		add		r7,r7:r0
; transfer data to the buffer
WROB1:
		ldd		r0,mar2:r0
		st		mar1:r0,r0
		loop	r6,Displacement WROB1
		li		r0,0
		lar		ar8,0
		li		r6,260
		li		r6,260 shr 8
		st		mar4:r6,r6						; write page
		li		r0,0ffh
		li		r0,03h
WROB4:
		nop
		loop	r0,displacement WROB4
		jnear	displacement WriteRestOfBlock
